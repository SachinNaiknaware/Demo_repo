## Exceptions 

# error detacted during execution are called exception an are not unconditionally fatal. most exceptions are not
# handald by programs
# try:
#     x = 5 / 0
# except ZeroDivisionError as e:
#     print("Got Divide by zero! the exception was  ",e)
#     x =0
# finally:
#     print("End")

# Operator
# Method
# Expression
# + Addition__add__(self, other)a1 + a2
# - Subtraction__sub__(self, other)a1 - a2
# * Multiplication__mul__(self, other)a1 * a2
# @ Matrix Multiplication__matmul__(self, other)a1 @ a2 (Python 3.5)
# / Division__div__(self, other)a1 / a2 (Python 2 only)
# / Division__truediv__(self, other)a1 / a2 (Python 3)
# // Floor Division__floordiv__(self, other)a1 // a2
# % Modulo/Remainder__mod__(self, other)a1 % a2
# ** Power__pow__(self, other[, modulo]) a1 ** a2
# << Bitwise Left Shift__lshift__(self, other)a1 << a2
# >> Bitwise Right Shift__rshift__(self, other)a1 >> a2
# & Bitwise AND__and__(self, other)a1 & a2
# ^ Bitwise XOR__xor__(self, other)a1 ^ a2
# | (Bitwise OR)__or__(self, other)a1 | a2
# - Negation (Arithmetic)__neg__(self)-a1
# + Positive__pos__(self)+a1
# ~ Bitwise NOT__invert__(self)~a1
# < Less than__lt__(self, other)a1 < a2
# <= Less than or Equal to__le__(self, other)a1 <= a2
# == Equal to__eq__(self, other)a1 == a2
# != Not Equal to__ne__(self, other)a1 != a2
# > Greater than__gt__(self, other)a1 > a2
# >= Greater than or Equal to __ge__(self, other)a1 >= a2
# [index] Index operator__getitem__(self, index)a1[index]
# in In operator__contains__(self, other)a2 in a1
# (*args, ...) Calling__call__(self, *args, **kwargs) a1(*args, **kwargs)

# import turtle

# ninja = turtle.Turtle()
# ninja.speed(10)

# for i in range(180):
#     ninja.forward(100)
#     ninja.right(30)
#     ninja.forward(20)
#     ninja.left(60)
#     ninja.forward(50)
#     ninja.right(30)
#     ninja.penup()
#     ninja.setposition(0, 0)
#     ninja.pendown()
#     ninja.right(2)

# turtle.done()



